<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/INSO-Blog/feed.xml" rel="self" type="application/atom+xml" /><link href="/INSO-Blog/" rel="alternate" type="text/html" /><updated>2019-12-03T13:16:08-04:00</updated><id>/INSO-Blog/feed.xml</id><title type="html">INSO4101 Learning Journal</title><subtitle>A blog for what was learned in the INSO4101 class in UPRM. </subtitle><entry><title type="html">Class conclusion</title><link href="/INSO-Blog/2019/12/01/Class-Conclusion.html" rel="alternate" type="text/html" title="Class conclusion" /><published>2019-12-01T00:00:00-04:00</published><updated>2019-12-01T00:00:00-04:00</updated><id>/INSO-Blog/2019/12/01/Class%20Conclusion</id><content type="html" xml:base="/INSO-Blog/2019/12/01/Class-Conclusion.html">&lt;h3 id=&quot;the-art-of-learning&quot;&gt;The Art of Learning&lt;/h3&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;It has come to an end. I have grown as an engineer and as a person. From this class I integrated time logging and this has helped me keep track of my time to use it more efficiently. I am sure that as I grow professionally this will be an essential skill to constantly keep improving myself and avoid being plateaued. More than the specific things I have learned in my courses like a specific programming language or how an operating system works. I have learned the art of learning and how to be passionate about it.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;To learn there are two very important things you need. Something that you like and can improve your life and organization. This is what the university provides because without university we could probably learn a lot of things, but we might ignore some things that we don’t like but are very necessary. Like this course for example which a lot of us might think we don’t need because we can “just get to coding and think about it on the way”. This may work but the tools provided in the course allow us to do it the right way from the beginning. I see it more like teaching a soldier to survive with the bare minimum; sure, most of the time they’ll have their guns, tools and everything they need but a great soldier will survive even in the middle of a forest with nothing but the clothing they have on.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;&lt;img src=&quot;/INSO-Blog/assets/army.jpg&quot; alt=&quot;&quot; /&gt;
I will be graduating soon and I will try to keep a lot of these tools in mind. I might not use a lot of them but since there are so many industries and so many types of managers and projects throughout my life which I might rotate through I will surely see tools like TLA+ which I had no idea existed. I think this course goes far and beyond to not keep things too introductory and really teaches us to use everything in a real way. Although I was lost for some parts of the course in the end I figured a lot of them out. The course can always keep improving so it is easier to understand specially when grading other students homeworks where I was lost since I didn’t have a tight grasp of what I was grading. Just like our field which is rather new the course can keep improving until it is creating the most robust software engineers.&lt;/p&gt;
&lt;h1 style=&quot;text-align: center&quot; id=&quot;happy-software-engineering&quot;&gt;Happy software engineering!&lt;/h1&gt;</content><author><name></name></author><summary type="html">The Art of Learning It has come to an end. I have grown as an engineer and as a person. From this class I integrated time logging and this has helped me keep track of my time to use it more efficiently. I am sure that as I grow professionally this will be an essential skill to constantly keep improving myself and avoid being plateaued. More than the specific things I have learned in my courses like a specific programming language or how an operating system works. I have learned the art of learning and how to be passionate about it. To learn there are two very important things you need. Something that you like and can improve your life and organization. This is what the university provides because without university we could probably learn a lot of things, but we might ignore some things that we don’t like but are very necessary. Like this course for example which a lot of us might think we don’t need because we can “just get to coding and think about it on the way”. This may work but the tools provided in the course allow us to do it the right way from the beginning. I see it more like teaching a soldier to survive with the bare minimum; sure, most of the time they’ll have their guns, tools and everything they need but a great soldier will survive even in the middle of a forest with nothing but the clothing they have on. I will be graduating soon and I will try to keep a lot of these tools in mind. I might not use a lot of them but since there are so many industries and so many types of managers and projects throughout my life which I might rotate through I will surely see tools like TLA+ which I had no idea existed. I think this course goes far and beyond to not keep things too introductory and really teaches us to use everything in a real way. Although I was lost for some parts of the course in the end I figured a lot of them out. The course can always keep improving so it is easier to understand specially when grading other students homeworks where I was lost since I didn’t have a tight grasp of what I was grading. Just like our field which is rather new the course can keep improving until it is creating the most robust software engineers. Happy software engineering!</summary></entry><entry><title type="html">Petri nets and sequence charts</title><link href="/INSO-Blog/2019/11/24/Petri-Nets-and-Sequence-Charts.html" rel="alternate" type="text/html" title="Petri nets and sequence charts" /><published>2019-11-24T00:00:00-04:00</published><updated>2019-11-24T00:00:00-04:00</updated><id>/INSO-Blog/2019/11/24/Petri%20Nets%20and%20Sequence%20Charts</id><content type="html" xml:base="/INSO-Blog/2019/11/24/Petri-Nets-and-Sequence-Charts.html">&lt;p style=&quot;text-align: justify&quot;&gt;More charts for visual people. After automata this was my favorite topic in the class. I am a very visual person so things like chats and diagrams are what really help me understand systems and the way their organized. I still like automatas more since they are basically the fundamental to everything that we do and that is very interesting to me. Although this is the case there is a need for different parts of a system. For example sequence charts show the way a system runs in respect to time. Other types of diagrams may show this too but it because of the way it’s organized it’s easier to quickly analyze what is going to happen next with a sequence chart.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;The other type of diagram we learned about is the petri net. This also adds to the complexity and helps us get the details of a system by showing how one thing moves from one place to another. The benefit of petri nets is to show the specific transition and the amount of elements that will fall into this transition.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;From the begining of time diagrams allow us to understand how the world works by looking at patterns. With the right chart a person who has no idea how a system works may give their input on their are of expertise without having to spend days, weeks or even months learning the details to then give input for a small area. Which brings us back to the importance of efficiency and constant improvement.&lt;/p&gt;</content><author><name></name></author><summary type="html">More charts for visual people. After automata this was my favorite topic in the class. I am a very visual person so things like chats and diagrams are what really help me understand systems and the way their organized. I still like automatas more since they are basically the fundamental to everything that we do and that is very interesting to me. Although this is the case there is a need for different parts of a system. For example sequence charts show the way a system runs in respect to time. Other types of diagrams may show this too but it because of the way it’s organized it’s easier to quickly analyze what is going to happen next with a sequence chart. The other type of diagram we learned about is the petri net. This also adds to the complexity and helps us get the details of a system by showing how one thing moves from one place to another. The benefit of petri nets is to show the specific transition and the amount of elements that will fall into this transition. From the begining of time diagrams allow us to understand how the world works by looking at patterns. With the right chart a person who has no idea how a system works may give their input on their are of expertise without having to spend days, weeks or even months learning the details to then give input for a small area. Which brings us back to the importance of efficiency and constant improvement.</summary></entry><entry><title type="html">Automata</title><link href="/INSO-Blog/2019/11/07/Automata.html" rel="alternate" type="text/html" title="Automata" /><published>2019-11-07T00:00:00-04:00</published><updated>2019-11-07T00:00:00-04:00</updated><id>/INSO-Blog/2019/11/07/Automata</id><content type="html" xml:base="/INSO-Blog/2019/11/07/Automata.html">&lt;p style=&quot;text-align: justify&quot;&gt;Automata was a very interesting topic for me. It is not the first time I saw since I have taken the class (CIIC5045) and also seen it in my programming languages course. This topic is used in every area of computer science and in fact is the fundament of the whole science. The first programs where state machines that would do simple steps but would solve complex problems and would advance our world to what it is today. It has always been interesting to me since it was used to create computer science and is what could solve some of our biggest modern problems. Automata itself won’t solve the probles but it does show if they can be solved or not. As we have already seen with things such as math and logic. We need to analyze the states of a machine to prove if it is possible. The idea to a problem might be great but it might be impossible to execute and this is what state diagrams help do.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;Although Atomatas are used in computer science and to prove things it is also useful because it is very visual and for us humans it is way easier to see things visualized. If we wanted to run a whole program in our mind while reading the states of the machine we would easily get lost. With the visual aspect it is very easy to analyze.&lt;/p&gt;</content><author><name></name></author><summary type="html">Automata was a very interesting topic for me. It is not the first time I saw since I have taken the class (CIIC5045) and also seen it in my programming languages course. This topic is used in every area of computer science and in fact is the fundament of the whole science. The first programs where state machines that would do simple steps but would solve complex problems and would advance our world to what it is today. It has always been interesting to me since it was used to create computer science and is what could solve some of our biggest modern problems. Automata itself won’t solve the probles but it does show if they can be solved or not. As we have already seen with things such as math and logic. We need to analyze the states of a machine to prove if it is possible. The idea to a problem might be great but it might be impossible to execute and this is what state diagrams help do. Although Atomatas are used in computer science and to prove things it is also useful because it is very visual and for us humans it is way easier to see things visualized. If we wanted to run a whole program in our mind while reading the states of the machine we would easily get lost. With the visual aspect it is very easy to analyze.</summary></entry><entry><title type="html">Modularization</title><link href="/INSO-Blog/2019/10/28/Modularization.html" rel="alternate" type="text/html" title="Modularization" /><published>2019-10-28T00:00:00-04:00</published><updated>2019-10-28T00:00:00-04:00</updated><id>/INSO-Blog/2019/10/28/Modularization</id><content type="html" xml:base="/INSO-Blog/2019/10/28/Modularization.html">&lt;p style=&quot;text-align: justify&quot;&gt;When working on complex projects topics have to be divided. This is where modularization is essential. If a project is too big and everything is mixed together. This will be impossible to digest and even create confusion when making all the specifications. It is recommended that topics are divided by domain and then into sub-domains or subjects that can allow it to be digested easier and written.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;This can also be useful if we treat it like we treat programs. When an application is being coded up a single person doesn’t work in every area. Each person is specialized in a topic and this can allow them to extensively work in this. The same way a domain expert can take a module after agreeing on the major ideas and make all the details for the specific module. This avoids a couple of people conflicting with their information because each team or person only has to work on one part and not everyone in every other part.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;Although modularization might not be a large topic by itself. It is an underlying thing to do in general and always be in the back of the mind of anyone working on the project to not step on anyone’s toes.&lt;/p&gt;</content><author><name></name></author><summary type="html">When working on complex projects topics have to be divided. This is where modularization is essential. If a project is too big and everything is mixed together. This will be impossible to digest and even create confusion when making all the specifications. It is recommended that topics are divided by domain and then into sub-domains or subjects that can allow it to be digested easier and written. This can also be useful if we treat it like we treat programs. When an application is being coded up a single person doesn’t work in every area. Each person is specialized in a topic and this can allow them to extensively work in this. The same way a domain expert can take a module after agreeing on the major ideas and make all the details for the specific module. This avoids a couple of people conflicting with their information because each team or person only has to work on one part and not everyone in every other part. Although modularization might not be a large topic by itself. It is an underlying thing to do in general and always be in the back of the mind of anyone working on the project to not step on anyone’s toes.</summary></entry><entry><title type="html">Domains</title><link href="/INSO-Blog/2019/10/10/Domains.html" rel="alternate" type="text/html" title="Domains" /><published>2019-10-10T00:00:00-04:00</published><updated>2019-10-10T00:00:00-04:00</updated><id>/INSO-Blog/2019/10/10/Domains</id><content type="html" xml:base="/INSO-Blog/2019/10/10/Domains.html">&lt;p style=&quot;text-align: justify&quot;&gt;Domains, this was a very new concept to me when it was first taught in class. After I understood it, like if it was the simplest idea, but I never had heard it as a specific term. A &lt;strong&gt;domain&lt;/strong&gt; by Wikipedia &lt;em&gt;“is a field of study that defines a set of common requirements, terminology, and functionality for any software program constructed to solve a problem in the area of computer programming, known as domain engineering.”&lt;/em&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;The first time you hear the term it sounds like it is too complicated like if it’s something totally foreign, when you think about it, it’s very simple. In simple terms it is the system or topic your application will be based on and your first thought might be &lt;em&gt;“I don’t need this I already know what i’m doing”&lt;/em&gt; and you might be right but that doesn’t mean you don’t needn to define your domain. As we mentioned in the post about documentation. The document we develop needs to be understood by anyone. In addition you’re trying to deliver a concrete image of what you’re working on.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;A domain makes you dig deep and hard into your topic and allows you to not take things as just basic and easy. For example, if you know a lot about finance you might think that making a banking system should be easy. When you dig deeper and understand other aspects like the laws and other details that us programmers don’t really think about from the get go.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;I have been programming since the age of 15 and I think that even if I didn’t study engineering I could’ve continued learning and gotten a job, but these are the types of things you might not learn in the practice. Implicitly we might do this but the structure provided by the things we learn in formal education is what separates a coder from a software engineer.&lt;/p&gt;</content><author><name></name></author><summary type="html">Domains, this was a very new concept to me when it was first taught in class. After I understood it, like if it was the simplest idea, but I never had heard it as a specific term. A domain by Wikipedia “is a field of study that defines a set of common requirements, terminology, and functionality for any software program constructed to solve a problem in the area of computer programming, known as domain engineering.” The first time you hear the term it sounds like it is too complicated like if it’s something totally foreign, when you think about it, it’s very simple. In simple terms it is the system or topic your application will be based on and your first thought might be “I don’t need this I already know what i’m doing” and you might be right but that doesn’t mean you don’t needn to define your domain. As we mentioned in the post about documentation. The document we develop needs to be understood by anyone. In addition you’re trying to deliver a concrete image of what you’re working on. A domain makes you dig deep and hard into your topic and allows you to not take things as just basic and easy. For example, if you know a lot about finance you might think that making a banking system should be easy. When you dig deeper and understand other aspects like the laws and other details that us programmers don’t really think about from the get go. I have been programming since the age of 15 and I think that even if I didn’t study engineering I could’ve continued learning and gotten a job, but these are the types of things you might not learn in the practice. Implicitly we might do this but the structure provided by the things we learn in formal education is what separates a coder from a software engineer.</summary></entry><entry><title type="html">Time management</title><link href="/INSO-Blog/2019/10/03/Time-Management.html" rel="alternate" type="text/html" title="Time management" /><published>2019-10-03T00:00:00-04:00</published><updated>2019-10-03T00:00:00-04:00</updated><id>/INSO-Blog/2019/10/03/Time%20Management</id><content type="html" xml:base="/INSO-Blog/2019/10/03/Time-Management.html">&lt;p style=&quot;text-align: justify&quot;&gt;Time management is essential to any team and personal life. Most of the people in the world. Go about their day without structure and just do one thing at a time or multiple but not being efficient in any of them. For a project manager this is not an option. Everything revolves around time for the manager. They are the ones responsible to make sure the team meets the deadlines and everything is delievered on time and working properly.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;Since starting this class one of the practices that we did in our homeworks was to show our timelog for time worked on the project. This could include our personal life or just related to the class and project. The point that the professor had was to make sure we log time to get a feel for how much time a task may take to do. Humans are bad at time but even worse at estimating. We might think that cooking only took 2 hours but in reality it may have taken 5 and we wasted a lot of time without noticing. When we log time this is not a problem because we start to see real numbers and this makes us better at planning and estimating.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;For the first homeworks I didn’t log too strictly I just saw my schedule and esimated the time that I spent doing the other things. Just by doing that I noticed that I didn’t know where my time was going. It was all mostly a blur. I went to class did some homework, but didn’t notice that I spent 6 hours doing the homework because I got distracted and spent 3 talking. After noticing this I started logging all of my time and it has been a habit that has stuck with me. Now 90% of my week I have it logged and I know exactly what I was doing (or a very close approximation to it).&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;From time logging I have learned how much time I really take doing tasks and a second benefit to this that I see is that I can tell that 15 minutes have passed since I interrupted my task and I feel desperate to get back to the task that I was doing. Hence making me more productive. The weeks that I was very mindful about every minute, I became so productive that there were days I literally had nothing else to do. This made me really happy. As the semester passed it hasn’t been as easy to stay improve, but I still keep logging time.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;From here on out I will keep time logging my time and will make sure to analyze at the end of the week. I think that doing this will be a very powerful combination for my future and can only bring positive things to my life.&lt;/p&gt;</content><author><name></name></author><summary type="html">Time management is essential to any team and personal life. Most of the people in the world. Go about their day without structure and just do one thing at a time or multiple but not being efficient in any of them. For a project manager this is not an option. Everything revolves around time for the manager. They are the ones responsible to make sure the team meets the deadlines and everything is delievered on time and working properly. Since starting this class one of the practices that we did in our homeworks was to show our timelog for time worked on the project. This could include our personal life or just related to the class and project. The point that the professor had was to make sure we log time to get a feel for how much time a task may take to do. Humans are bad at time but even worse at estimating. We might think that cooking only took 2 hours but in reality it may have taken 5 and we wasted a lot of time without noticing. When we log time this is not a problem because we start to see real numbers and this makes us better at planning and estimating. For the first homeworks I didn’t log too strictly I just saw my schedule and esimated the time that I spent doing the other things. Just by doing that I noticed that I didn’t know where my time was going. It was all mostly a blur. I went to class did some homework, but didn’t notice that I spent 6 hours doing the homework because I got distracted and spent 3 talking. After noticing this I started logging all of my time and it has been a habit that has stuck with me. Now 90% of my week I have it logged and I know exactly what I was doing (or a very close approximation to it). From time logging I have learned how much time I really take doing tasks and a second benefit to this that I see is that I can tell that 15 minutes have passed since I interrupted my task and I feel desperate to get back to the task that I was doing. Hence making me more productive. The weeks that I was very mindful about every minute, I became so productive that there were days I literally had nothing else to do. This made me really happy. As the semester passed it hasn’t been as easy to stay improve, but I still keep logging time. From here on out I will keep time logging my time and will make sure to analyze at the end of the week. I think that doing this will be a very powerful combination for my future and can only bring positive things to my life.</summary></entry><entry><title type="html">Importance of planning</title><link href="/INSO-Blog/2019/09/29/Importance-of-Planning.html" rel="alternate" type="text/html" title="Importance of planning" /><published>2019-09-29T00:00:00-04:00</published><updated>2019-09-29T00:00:00-04:00</updated><id>/INSO-Blog/2019/09/29/Importance%20of%20Planning</id><content type="html" xml:base="/INSO-Blog/2019/09/29/Importance-of-Planning.html">&lt;p style=&quot;text-align: justify&quot;&gt;As mentioned in the previous posts the goal for all of this is to have a plan and an accurate picture of what is the end goal and after that goal is rearched the plan on how to continue and continue appropriately. Nothing can be done in any of the engineerings without appropriate planning. In civil engineering for example, they have plans before they build something; Industrial engineering, have to constantly plan ahead, whach out for mistake and keep everything in line.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;Software engineering compared to the other engineering specialities is realatively new. We are constantly building new systems to build different types of application and although there are many methodologies. Everyone has an opinion on what the best one is. For example, there is agile. A lot of the industries use this methodology and many think this is the standard for project management. Even though it is used by a grand majority in the modern time. It still has a long way to go before there is something definitive.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;Logic and math is just the ground work for this. As mentioned in the syllabus there will be better specification of all this when we understand how to deal with Domains, automata and a few other tools which only help to improve the documentation and the planning process. Although all this could greatly improve the planning process there is still a lot of room left to go.&lt;/p&gt;</content><author><name></name></author><summary type="html">As mentioned in the previous posts the goal for all of this is to have a plan and an accurate picture of what is the end goal and after that goal is rearched the plan on how to continue and continue appropriately. Nothing can be done in any of the engineerings without appropriate planning. In civil engineering for example, they have plans before they build something; Industrial engineering, have to constantly plan ahead, whach out for mistake and keep everything in line. Software engineering compared to the other engineering specialities is realatively new. We are constantly building new systems to build different types of application and although there are many methodologies. Everyone has an opinion on what the best one is. For example, there is agile. A lot of the industries use this methodology and many think this is the standard for project management. Even though it is used by a grand majority in the modern time. It still has a long way to go before there is something definitive. Logic and math is just the ground work for this. As mentioned in the syllabus there will be better specification of all this when we understand how to deal with Domains, automata and a few other tools which only help to improve the documentation and the planning process. Although all this could greatly improve the planning process there is still a lot of room left to go.</summary></entry><entry><title type="html">Logic and math</title><link href="/INSO-Blog/2019/09/18/Logic-and-Math.html" rel="alternate" type="text/html" title="Logic and math" /><published>2019-09-18T00:00:00-04:00</published><updated>2019-09-18T00:00:00-04:00</updated><id>/INSO-Blog/2019/09/18/Logic%20and%20Math</id><content type="html" xml:base="/INSO-Blog/2019/09/18/Logic-and-Math.html">&lt;p style=&quot;text-align: justify&quot;&gt;Algebra and mathematical logic are the more formal ways of defining what wants to be built. Math is universal and with rather small background in engineering and programming a person could analyze the models that are presented. The logic allows the program to be checked for any basic logical problems that may arrise. This may be a simple boolean but sometimes the underlying algorithm is not logically or mathenatically possible. Utilizing this tool helps mitigate this problem&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;Since math is fundamental in every part of our life it is essential. Some of the ways the logic and math may be used is by making propositional logic or using previously established axioms. In addition, any mathematical explanation should not be overly complicated and should be appropriately quantifiable. Every technical aspect has some underlying math and logic built into it even if it is not explicitly written.&lt;/p&gt;</content><author><name></name></author><summary type="html">Algebra and mathematical logic are the more formal ways of defining what wants to be built. Math is universal and with rather small background in engineering and programming a person could analyze the models that are presented. The logic allows the program to be checked for any basic logical problems that may arrise. This may be a simple boolean but sometimes the underlying algorithm is not logically or mathenatically possible. Utilizing this tool helps mitigate this problem Since math is fundamental in every part of our life it is essential. Some of the ways the logic and math may be used is by making propositional logic or using previously established axioms. In addition, any mathematical explanation should not be overly complicated and should be appropriately quantifiable. Every technical aspect has some underlying math and logic built into it even if it is not explicitly written.</summary></entry><entry><title type="html">Documentation</title><link href="/INSO-Blog/2019/09/09/Documentation.html" rel="alternate" type="text/html" title="Documentation" /><published>2019-09-09T00:00:00-04:00</published><updated>2019-09-09T00:00:00-04:00</updated><id>/INSO-Blog/2019/09/09/Documentation</id><content type="html" xml:base="/INSO-Blog/2019/09/09/Documentation.html">&lt;p style=&quot;text-align: justify&quot;&gt;Documentation is the fundamental and backbone of any Software Engineering project. Without documentation the planning of the application will be much more complicated or maybe even impossible if it’s a project that is starting out. If it’s a project that is fully developed than it is still important to understand the whole backbone or specifics about the code.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;Without appropriate documentation any engineer working on the project might take way longer to develop or understand. This is time and resources wasted for the engineer and the company that he/she might be working for and in a modern world we live in it is extremely important to be efficient as possible. This may be the difference between a successful company or an average or bad company.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;The following has to be understood by anyone related to the project even if they don’t have knowledge in software engineering. This removes any limitation and getting too involved in coding errors or differences in opinions. This also helps other domain experts give their opinion about a subject that the coders or project managers might not have knowledge in.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;Each document may vary widely between each project. Some projects require every single detail to be laid out because not doing so my result in life’s lost or an extraordinary amount of money to be wasted. It can also be seen as a type of introduction for the whole document so any reader can get a feel for what they will be analyzing if they are new to the project.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;As we have seen documentation is very important in software engineering and most posts will continue on ideas and details about this topic.&lt;/p&gt;</content><author><name></name></author><summary type="html">Documentation is the fundamental and backbone of any Software Engineering project. Without documentation the planning of the application will be much more complicated or maybe even impossible if it’s a project that is starting out. If it’s a project that is fully developed than it is still important to understand the whole backbone or specifics about the code. Without appropriate documentation any engineer working on the project might take way longer to develop or understand. This is time and resources wasted for the engineer and the company that he/she might be working for and in a modern world we live in it is extremely important to be efficient as possible. This may be the difference between a successful company or an average or bad company. The following has to be understood by anyone related to the project even if they don’t have knowledge in software engineering. This removes any limitation and getting too involved in coding errors or differences in opinions. This also helps other domain experts give their opinion about a subject that the coders or project managers might not have knowledge in. Each document may vary widely between each project. Some projects require every single detail to be laid out because not doing so my result in life’s lost or an extraordinary amount of money to be wasted. It can also be seen as a type of introduction for the whole document so any reader can get a feel for what they will be analyzing if they are new to the project. As we have seen documentation is very important in software engineering and most posts will continue on ideas and details about this topic.</summary></entry><entry><title type="html">Introduction</title><link href="/INSO-Blog/2019/09/07/Introduction.html" rel="alternate" type="text/html" title="Introduction" /><published>2019-09-07T00:00:00-04:00</published><updated>2019-09-07T00:00:00-04:00</updated><id>/INSO-Blog/2019/09/07/Introduction</id><content type="html" xml:base="/INSO-Blog/2019/09/07/Introduction.html">&lt;p style=&quot;text-align: justify&quot;&gt;My name is Luis Liz and I am a Computer Scince Engineering student in the University of Puerto Rico. After taking many fundamental classes in everything related to programming and engineering in general. I am finishing my concentration courses and this is one of those courses.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;As part of the classwork required by the class is a blog where we can talk about everything that we have learned. Throughout the semester I will be posting about things we learn in the class and my personal view on them. Although this material is for the class it will hopefully help someone out that might be taking the class in another campus or university.&lt;/p&gt;
&lt;p style=&quot;text-align: justify&quot;&gt;The class presented is Introduction to Software Engineering. In this class instead of learning about the programming or engineering aspects of our career we will have a more managerial and abstract look at the projects we will work on. The end product of any type of project in this field is most likely code, but a project can’t be started with code from the beginning. A planning and exploration phases are needed to deliver a product the most productive and best way possible. Where everyone is on the same page and ready to work on their part. This is what I hope to accomplish in this course.&lt;/p&gt;</content><author><name></name></author><summary type="html">My name is Luis Liz and I am a Computer Scince Engineering student in the University of Puerto Rico. After taking many fundamental classes in everything related to programming and engineering in general. I am finishing my concentration courses and this is one of those courses. As part of the classwork required by the class is a blog where we can talk about everything that we have learned. Throughout the semester I will be posting about things we learn in the class and my personal view on them. Although this material is for the class it will hopefully help someone out that might be taking the class in another campus or university. The class presented is Introduction to Software Engineering. In this class instead of learning about the programming or engineering aspects of our career we will have a more managerial and abstract look at the projects we will work on. The end product of any type of project in this field is most likely code, but a project can’t be started with code from the beginning. A planning and exploration phases are needed to deliver a product the most productive and best way possible. Where everyone is on the same page and ready to work on their part. This is what I hope to accomplish in this course.</summary></entry></feed>